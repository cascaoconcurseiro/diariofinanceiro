import { useState, useEffect, useCallback } from 'react';
import { calculateNextRecurringDate, isValidRecurringDate } from '../utils/recurringDateCalculator';

// Importar teste em desenvolvimento
if (process.env.NODE_ENV === 'development') {
  import('../tests/recurringDateTest');
}

export interface RecurringTransaction {
  id: string;
  type: 'entrada' | 'saida';
  amount: number;
  description: string;
  dayOfMonth: number;
  frequency: 'until-cancelled' | 'fixed-count' | 'monthly-duration';
  remainingCount?: number;
  monthsDuration?: number;
  remainingMonths?: number;
  startDate: string; // ISO date string
  isActive: boolean;
  createdAt: string;
}

const STORAGE_KEY = 'recurringTransactions';

export const useRecurringTransactions = () => {
  const [recurringTransactions, setRecurringTransactions] = useState<RecurringTransaction[]>([]);

  // Load from localStorage on mount
  useEffect(() => {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (saved) {
      try {
        const parsed = JSON.parse(saved);
        if (Array.isArray(parsed)) {
          setRecurringTransactions(parsed);
          console.log('ðŸ’¾ Loaded recurring transactions:', parsed.length);
        }
      } catch (error) {
        console.error('âŒ Error loading recurring transactions:', error);
        setRecurringTransactions([]);
      }
    }
  }, []);

  // Save to localStorage whenever data changes
  useEffect(() => {
    console.log('ðŸ’¾ Saving recurring transactions:', recurringTransactions.length);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(recurringTransactions));
  }, [recurringTransactions]);

  const addRecurringTransaction = useCallback((
    transaction: Omit<RecurringTransaction, 'id' | 'createdAt' | 'startDate'>
  ): RecurringTransaction => {
    // CORREÃ‡ÃƒO: Usar utilitÃ¡rio para calcular prÃ³xima data vÃ¡lida
    const nextValidDate = calculateNextRecurringDate({
      dayOfMonth: transaction.dayOfMonth,
      frequency: transaction.frequency === 'until-cancelled' ? 'monthly' : 
                 transaction.frequency === 'fixed-count' ? 'fixed-count' : 'monthly-duration'
    });

    const newTransaction: RecurringTransaction = {
      ...transaction,
      id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      createdAt: new Date().toISOString(),
      startDate: nextValidDate.toISOString()
    };
    
    console.log(`âž• Adding recurring transaction with corrected start date: ${nextValidDate.toLocaleDateString()}`, newTransaction);
    setRecurringTransactions(prev => [...prev, newTransaction]);
    
    return newTransaction;
  }, []);

  const updateRecurringTransaction = useCallback((
    id: string, 
    updates: Partial<RecurringTransaction>
  ): void => {
    console.log('âœï¸ Updating recurring transaction:', id, updates);
    setRecurringTransactions(prev =>
      prev.map(t => t.id === id ? { ...t, ...updates } : t)
    );
  }, []);

  const deleteRecurringTransaction = useCallback((id: string, deleteGeneratedTransactions: boolean = true): void => {
    console.log('ðŸ—‘ï¸ Deleting recurring transaction:', id, 'deleteGenerated:', deleteGeneratedTransactions);
    
    // CORREÃ‡ÃƒO: Remover o lanÃ§amento recorrente
    setRecurringTransactions(prev => prev.filter(t => t.id !== id));
    
    // CORREÃ‡ÃƒO: Se solicitado, tambÃ©m remover todos os lanÃ§amentos gerados por este recorrente
    if (deleteGeneratedTransactions) {
      // Esta funÃ§Ã£o serÃ¡ chamada pelo componente pai que tem acesso ao sistema unificado
      console.log(`ðŸ§¹ Requesting deletion of all transactions generated by recurring ${id}`);
    }
  }, []);

  const getActiveRecurringTransactions = useCallback((): RecurringTransaction[] => {
    return recurringTransactions.filter(t => t.isActive);
  }, [recurringTransactions]);

  const getNextExecutionDate = useCallback((transaction: RecurringTransaction): Date | null => {
    if (!transaction.isActive) return null;
    
    const startDate = new Date(transaction.startDate);
    if (!isValidRecurringDate(startDate)) {
      // Se a data de inÃ­cio jÃ¡ passou, calcular a prÃ³xima
      return calculateNextRecurringDate({
        dayOfMonth: transaction.dayOfMonth,
        frequency: transaction.frequency === 'until-cancelled' ? 'monthly' : 
                   transaction.frequency === 'fixed-count' ? 'fixed-count' : 'monthly-duration'
      });
    }
    
    return startDate;
  }, []);

  return {
    recurringTransactions,
    addRecurringTransaction,
    updateRecurringTransaction,
    deleteRecurringTransaction,
    getActiveRecurringTransactions,
    getNextExecutionDate
  };
};