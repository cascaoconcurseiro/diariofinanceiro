/**
 * SISTEMA DE ARMAZENAMENTO CRIPTOGRAFADO
 * 
 * Implementa criptografia local para dados sensíveis no localStorage
 */

import { logger } from './logger';
import { encryptData, decryptData } from './securitySystem';

// Chaves para diferentes tipos de dados
const STORAGE_KEYS = {
  FINANCIAL_DATA: 'unifiedFinancialData',
  USER_PREFERENCES: 'userPreferences',
  ADMIN_SETTINGS: 'adminSettings',
  BACKUP_DATA: 'backupData'
} as const;

// Configuração de criptografia
const ENCRYPTION_CONFIG = {
  enabled: true, // Pode ser desabilitado para desenvolvimento
  keyRotationInterval: 24 * 60 * 60 * 1000, // 24 horas
  compressionEnabled: true
};

/**
 * Comprime dados usando algoritmo simples
 */
function compressData(data: string): string {
  try {
    // Implementação simples de compressão (RLE - Run Length Encoding)
    let compressed = '';
    let count = 1;
    
    for (let i = 0; i < data.length; i++) {
      if (i < data.length - 1 && data[i] === data[i + 1]) {
        count++;
      } else {
        if (count > 3) {\n          compressed += `${data[i]}${count}`;\n        } else {\n          compressed += data[i].repeat(count);\n        }\n        count = 1;\n      }\n    }\n    \n    return compressed.length < data.length ? compressed : data;\n  } catch (error) {\n    logger.warn('STORAGE', 'Compression failed, using original data', { error });\n    return data;\n  }\n}\n\n/**\n * Descomprime dados\n */\nfunction decompressData(compressedData: string): string {\n  try {\n    let decompressed = '';\n    let i = 0;\n    \n    while (i < compressedData.length) {\n      const char = compressedData[i];\n      \n      // Verificar se próximo caractere é um número\n      if (i + 1 < compressedData.length && /\\d/.test(compressedData[i + 1])) {\n        let numStr = '';\n        let j = i + 1;\n        \n        // Extrair número completo\n        while (j < compressedData.length && /\\d/.test(compressedData[j])) {\n          numStr += compressedData[j];\n          j++;\n        }\n        \n        const count = parseInt(numStr);\n        decompressed += char.repeat(count);\n        i = j;\n      } else {\n        decompressed += char;\n        i++;\n      }\n    }\n    \n    return decompressed;\n  } catch (error) {\n    logger.warn('STORAGE', 'Decompression failed, using original data', { error });\n    return compressedData;\n  }\n}\n\n/**\n * Metadata para dados criptografados\n */\ninterface EncryptedMetadata {\n  version: string;\n  timestamp: number;\n  compressed: boolean;\n  checksum: string;\n}\n\n/**\n * Gera checksum simples para validação de integridade\n */\nfunction generateChecksum(data: string): string {\n  let hash = 0;\n  for (let i = 0; i < data.length; i++) {\n    const char = data.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n  return hash.toString(36);\n}\n\n/**\n * Valida checksum dos dados\n */\nfunction validateChecksum(data: string, expectedChecksum: string): boolean {\n  const actualChecksum = generateChecksum(data);\n  return actualChecksum === expectedChecksum;\n}\n\n/**\n * Salva dados criptografados no localStorage\n */\nexport function setEncryptedItem(key: string, value: any): boolean {\n  try {\n    const jsonString = JSON.stringify(value);\n    const timestamp = Date.now();\n    \n    // Comprimir se habilitado\n    const processedData = ENCRYPTION_CONFIG.compressionEnabled ? \n      compressData(jsonString) : jsonString;\n    \n    // Criptografar se habilitado\n    const finalData = ENCRYPTION_CONFIG.enabled ? \n      encryptData(processedData) : processedData;\n    \n    // Criar metadata\n    const metadata: EncryptedMetadata = {\n      version: '1.0',\n      timestamp,\n      compressed: ENCRYPTION_CONFIG.compressionEnabled,\n      checksum: generateChecksum(jsonString)\n    };\n    \n    // Armazenar dados e metadata\n    const storageData = {\n      data: finalData,\n      metadata\n    };\n    \n    localStorage.setItem(key, JSON.stringify(storageData));\n    \n    logger.debug('STORAGE', 'Data encrypted and stored', { \n      key, \n      originalSize: jsonString.length,\n      finalSize: finalData.length,\n      compressed: metadata.compressed,\n      encrypted: ENCRYPTION_CONFIG.enabled\n    });\n    \n    return true;\n  } catch (error) {\n    logger.error('STORAGE', 'Failed to encrypt and store data', { key, error });\n    return false;\n  }\n}\n\n/**\n * Recupera e descriptografa dados do localStorage\n */\nexport function getEncryptedItem<T>(key: string): T | null {\n  try {\n    const stored = localStorage.getItem(key);\n    if (!stored) return null;\n    \n    // Tentar parsear como dados criptografados\n    let storageData;\n    try {\n      storageData = JSON.parse(stored);\n    } catch {\n      // Fallback para dados não criptografados (compatibilidade)\n      logger.warn('STORAGE', 'Found unencrypted data, migrating', { key });\n      const parsed = JSON.parse(stored);\n      \n      // Migrar para formato criptografado\n      setEncryptedItem(key, parsed);\n      return parsed;\n    }\n    \n    // Verificar se tem estrutura de dados criptografados\n    if (!storageData.data || !storageData.metadata) {\n      // Dados antigos, migrar\n      logger.info('STORAGE', 'Migrating legacy data format', { key });\n      setEncryptedItem(key, storageData);\n      return storageData;\n    }\n    \n    const { data, metadata } = storageData;\n    \n    // Descriptografar se necessário\n    const decryptedData = ENCRYPTION_CONFIG.enabled ? \n      decryptData(data) : data;\n    \n    // Descomprimir se necessário\n    const finalData = metadata.compressed ? \n      decompressData(decryptedData) : decryptedData;\n    \n    // Validar integridade\n    if (!validateChecksum(finalData, metadata.checksum)) {\n      logger.error('STORAGE', 'Data integrity check failed', { key });\n      return null;\n    }\n    \n    const parsed = JSON.parse(finalData);\n    \n    logger.debug('STORAGE', 'Data decrypted and retrieved', { \n      key,\n      age: Date.now() - metadata.timestamp,\n      version: metadata.version\n    });\n    \n    return parsed;\n  } catch (error) {\n    logger.error('STORAGE', 'Failed to decrypt and retrieve data', { key, error });\n    return null;\n  }\n}\n\n/**\n * Remove item criptografado\n */\nexport function removeEncryptedItem(key: string): boolean {\n  try {\n    localStorage.removeItem(key);\n    logger.debug('STORAGE', 'Encrypted item removed', { key });\n    return true;\n  } catch (error) {\n    logger.error('STORAGE', 'Failed to remove encrypted item', { key, error });\n    return false;\n  }\n}\n\n/**\n * Verifica se item existe\n */\nexport function hasEncryptedItem(key: string): boolean {\n  return localStorage.getItem(key) !== null;\n}\n\n/**\n * Limpa todos os dados criptografados\n */\nexport function clearEncryptedStorage(): boolean {\n  try {\n    Object.values(STORAGE_KEYS).forEach(key => {\n      localStorage.removeItem(key);\n    });\n    \n    logger.info('STORAGE', 'All encrypted storage cleared');\n    return true;\n  } catch (error) {\n    logger.error('STORAGE', 'Failed to clear encrypted storage', { error });\n    return false;\n  }\n}\n\n/**\n * Obtém estatísticas do armazenamento\n */\nexport function getStorageStats(): {\n  totalItems: number;\n  totalSize: number;\n  encryptedItems: number;\n  compressionRatio: number;\n} {\n  let totalItems = 0;\n  let totalSize = 0;\n  let encryptedItems = 0;\n  let originalSize = 0;\n  let compressedSize = 0;\n  \n  try {\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (!key) continue;\n      \n      const value = localStorage.getItem(key);\n      if (!value) continue;\n      \n      totalItems++;\n      totalSize += value.length;\n      \n      // Verificar se é item criptografado\n      try {\n        const parsed = JSON.parse(value);\n        if (parsed.data && parsed.metadata) {\n          encryptedItems++;\n          \n          // Calcular ratio de compressão se disponível\n          if (parsed.metadata.compressed) {\n            compressedSize += parsed.data.length;\n            // Estimar tamanho original baseado no checksum\n            originalSize += parsed.data.length * 1.2; // Estimativa\n          }\n        }\n      } catch {\n        // Não é item criptografado\n      }\n    }\n    \n    return {\n      totalItems,\n      totalSize,\n      encryptedItems,\n      compressionRatio: originalSize > 0 ? compressedSize / originalSize : 1\n    };\n  } catch (error) {\n    logger.error('STORAGE', 'Failed to get storage stats', { error });\n    return {\n      totalItems: 0,\n      totalSize: 0,\n      encryptedItems: 0,\n      compressionRatio: 1\n    };\n  }\n}\n\n/**\n * Migra dados existentes para formato criptografado\n */\nexport function migrateToEncryptedStorage(): boolean {\n  try {\n    logger.info('STORAGE', 'Starting migration to encrypted storage');\n    \n    // Migrar dados financeiros\n    const financialData = localStorage.getItem(STORAGE_KEYS.FINANCIAL_DATA);\n    if (financialData) {\n      try {\n        const parsed = JSON.parse(financialData);\n        setEncryptedItem(STORAGE_KEYS.FINANCIAL_DATA, parsed);\n        logger.debug('STORAGE', 'Financial data migrated');\n      } catch (error) {\n        logger.warn('STORAGE', 'Failed to migrate financial data', { error });\n      }\n    }\n    \n    logger.info('STORAGE', 'Migration to encrypted storage completed');\n    return true;\n  } catch (error) {\n    logger.error('STORAGE', 'Migration to encrypted storage failed', { error });\n    return false;\n  }\n}\n\n// Wrapper functions para compatibilidade\nexport const encryptedStorage = {\n  setItem: setEncryptedItem,\n  getItem: getEncryptedItem,\n  removeItem: removeEncryptedItem,\n  hasItem: hasEncryptedItem,\n  clear: clearEncryptedStorage,\n  getStats: getStorageStats,\n  migrate: migrateToEncryptedStorage,\n  \n  // Constantes\n  KEYS: STORAGE_KEYS\n};\n\nexport default encryptedStorage;